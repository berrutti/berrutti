<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Without npm - Matias Berrutti</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <nav class="blog-nav">
        <a href="../../index.html" class="nav-home">Home</a>
        <a href="../../about.html">About</a>
        <a href="../../archive.html">Archive</a>
        <a href="../../rss.xml">RSS</a>
    </nav>
    
    <main>
        <article class="single-post">
            <header class="post-header">
                <h1 class="post-title">Building Without npm</h1>
                <time class="post-date" datetime="2025-09-05">September 5, 2025</time>
            </header>
            <div class="post-content">
            <p>The JavaScript ecosystem has convinced us that we need a package manager for everything. But what if we don't?</p>
            
            <p>This blog is mostly accessible and readable without complex build tools.* The HTML itself is real, semantic markup that works everywhere. No virtual DOM, no hydration, no framework lock-in.</p>
            
            <p><small>* There are some automated steps for RSS and archive generation, which I'll discuss at the end of this post.</small></p>
            
            <p>Web components give us modularity without the complexity. The platform has evolved—maybe it's time our development practices caught up.</p>
            
            <h3>The Dependency Problem</h3>
            <p>Modern JavaScript projects often have hundreds or thousands of dependencies. Each dependency is a potential security vulnerability, a maintenance burden, and a point of failure.</p>
            
            <p>When you run <code>npm audit</code> on a typical React project, you'll see dozens of vulnerabilities. Most developers just run <code>npm audit fix</code> and hope for the best.</p>
            
            <h3>What We Actually Need</h3>
            <p>For most web projects, we need surprisingly little:</p>
            <ul>
                <li>HTML for structure</li>
                <li>CSS for styling</li>
                <li>Minimal JavaScript for interactivity</li>
                <li>Web components for reusability</li>
            </ul>
            
            <p>The browser provides everything else: HTTP requests, DOM manipulation, event handling, and more.</p>
            
            <h3>Web Components: The Native Solution</h3>
            <p>Web components aren't new technology - they've been supported in all major browsers for years. They provide the modularity of React components with the simplicity of HTML.</p>
            
            <p>No JSX compilation, no virtual DOM, no framework lock-in. Just standard web APIs that will work for decades.</p>
            
            <p><strong>Important caveat:</strong> Web components do require JavaScript to work. If someone has JS disabled, they'll see the raw content but lose the formatting and navigation. This is a tradeoff between modularity and progressive enhancement that's worth considering for your use case.</p>
            
            <h3>The Build Step Trap</h3>
            <p>Build steps add complexity without always adding value. Every build tool is another dependency to maintain, another configuration file to debug, another potential point of failure.</p>
            
            <p>For content-focused websites, the build step often optimizes for problems that don't exist while creating problems that do.</p>
            
            <h3>When npm Makes Sense</h3>
            <p>That said, npm isn't inherently evil. It's a powerful tool when used judiciously. This blog actually uses npm, but only for development and automation:</p>
            
            <ul>
                <li><strong>Development server</strong> - <code>npm run dev</code> starts a local server</li>
                <li><strong>RSS generation</strong> - <code>npm run generate-rss</code> automatically creates the RSS feed</li>
                <li><strong>GitHub Actions</strong> - Automated RSS updates when posts are added</li>
            </ul>
            
            <p>The key difference? Zero runtime dependencies. The generated site contains no npm packages, no node_modules, no JavaScript frameworks. npm is purely a development tool.</p>
            
            <h3>The Automated Steps</h3>
            <p>While the HTML is hand-written and readable, this blog does use some automation behind the scenes:</p>
            
            <ul>
                <li><strong>RSS generation</strong> - A Node.js script scans all posts and generates the RSS feed automatically</li>
                <li><strong>Archive page</strong> - The same script generates the archive page, grouping posts by date</li>
                <li><strong>GitHub Actions</strong> - When I push new posts, the RSS and archive update automatically</li>
            </ul>
            
            <p>The key difference? The HTML content itself is real, semantic markup. The automation just creates index pages and feeds - it doesn't transform or bundle the core content.</p>
            
            <h3>The Middle Path</h3>
            <p>The goal isn't to avoid all tools, but to choose them wisely. Use npm for automation and development convenience, but don't let it creep into your production bundle.</p>
            
            <p>This approach gives you the best of both worlds: modern development tooling when you need it, and a clean, fast website for your users.</p>
            </div>
            <footer class="post-footer">
                <a href="../../index.html">← Back to all posts</a>
            </footer>
        </article>
    </main>

</body>
</html>
